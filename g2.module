<?php

/**
 * @file
 * This defines a node-based glossary module, vs the term-based glossary.
 *
 * @todo Test wipes, rss
 *
 * @todo For D8, in decreasing priorities
 *  - implement SettingsForm::validateForm() using Requirements
 *  - make g2_requirements() less verbose, at least on success.
 *  - find a way to add the title to the node.add route for ease of creation.
 * @copyright 2005-2023 Frédéric G. Marand, for Ouest Systemes Informatiques.
 *
 * @link http://wiki.audean.com/g2/choosing @endlink
 */

use Drupal\Component\Utility\Html;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Access\AccessResultInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\Entity\EntityViewMode;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Extension\ExtensionPathResolver;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\GeneratedLink;
use Drupal\Core\Link;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\g2\G2;
use Drupal\g2\Top;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use function Drupal\g2\Indexer;

// Code in this part of the module is finalized for Drupal 10/9.

/**
 * Implements hook_cron().
 *
 * In G2's case, change the WOTD once a day if this feature is enabled,
 * which is the default case.
 */
function g2_cron() {
  /** @var \Drupal\g2\WOTD $wotd */
  $wotd = \Drupal::service(G2::SVC_WOTD);
  $wotd->cron();
}

/**
 * Implements hook_help().
 */
function g2_help($route_name, RouteMatchInterface $route_match) {
  $result = '';
  switch ($route_name) {
    case 'help.page.g2':
      $result = t(
        '<p>G2 defines a glossary service for Drupal sites.
       To compare it with the Glossary and Lexicon modules:</p>
       <ul>
         <li>G2 content is node-based, not term-based, allowing node access control</li>
         <li>G2 leverages existing code from glossary for input filtering and node marking</li>
         <li>G2 RAM use does not significantly increase with larger entry counts, which makes is more suitable for larger glossaries</li>
         <li>G2 requests much less from the database than the default glossary</li>
         <li>G2 uses a "G2 Context" taxonomy vocabulary by default, but does not require it.</li>
         <li>G2 defines optional blocks</li>
         <li>G2 provides a client and server XML-RPC API</li>
         <li>G2 does not provide term feeds</li>
         </ul>'
      );
      break;

    case 'entity.block.edit_form':
      // G2 block plugins contain a "help" annotation.
      $definition = $route_match
        ->getParameter('block')
        ->getPlugin()
        ->getPluginDefinition();
      if ($definition['provider'] !== 'g2') {
        return NULL;
      }
      $result = $definition['help'] ?? '';
      break;

    case 'entity.entity_view_display.node.view_mode':
      if ($route_match->getParameter('entity_type_id') != G2::TYPE) {
        break;
      }
      if ($route_match->getParameter('bundle') !== G2::BUNDLE) {
        break;
      }
      $name = $route_match->getParameter('view_mode_name');
      $args = ['%vm' => EntityViewMode::load(G2::TYPE . ".${name}")->label()];
      switch ($name) {
        case G2::VM_BLOCK:
          $result = t('The %vm display is used by the G2 Random and WOTD blocks.', $args);
          break;

        case G2::VM_ENTRY_LIST:
          $result = t('The %vm display is used by the G2 "terms by initial" page and the homonyms page in "plain node list" mode.', $args);
          break;

        case G2::VM_HOMONYMS_PAGE:
          $result = t('The %vm display is used by the G2 homonyms disambiguation page when it is configured to use a node (which is deprecated) instead of a route.', $args);
          break;

        case G2::VM_TOOLTIPS:
          $result = t('The %vm display is used by the G2 definition filter when tooltips are configured to use teasers');
          break;
      }
      if (!empty($result)) {
        $result = ['#markup' => "<p>${result}</p>\n"];
      }
  }

  return $result;
}

/**
 * Implements hook_ENTITY_TYPE_delete() for nodes.
 */
function g2_node_delete(NodeInterface $node) {
  /** @var \Drupal\g2\Matcher $matcher */
  $matcher = Drupal::service(G2::SVC_MATCHER);
  $matcher->rebuild();
}

/**
 * Implements hook_ENTITY_TYPE_insert() for nodes.
 */
function g2_node_insert(NodeInterface $node) {
  /** @var \Drupal\g2\Matcher $matcher */
  $matcher = Drupal::service(G2::SVC_MATCHER);
  $matcher->rebuild();
}

/**
 * Implements hook_ENTITY_TYPE_update() for nodes.
 */
function g2_node_update(NodeInterface $node) {
  /** @var \Drupal\g2\Matcher $matcher */
  $matcher = Drupal::service(G2::SVC_MATCHER);
  $matcher->rebuild();
}

// Code in this part of the module works in D10/9 but may not be finalized.

/**
 * Implements hook_xmlrpc().
 *
 * Note that functions returning node portions return them unfiltered.
 * It is the caller's responsibility to apply filtering depending on
 * its actual use of the data.
 */
function g2_xmlrpc() {
  $mapping = [
    // D10/9 OK
    'g2.alphabar' => '_g2_alphabar',
    'g2.api' => [G2::class, 'api'],
    'g2.latest' => '_g2_latest',
    'g2.stats' => '_g2_stats',
    'g2.top' => '_g2_top',

    // D10/9 exception
    'g2.random' => [\Drupal::service(G2::SVC_RANDOM), 'get'],
    'g2.wotd' => '_g2_wotd',
  ];

  $enabled = Drupal::config(G2::CONFIG_NAME)->get(G2::VARAPIENABLED);
  if (!$enabled) {
    $mapping = [];
  }

  return $mapping;
}

// Code in this part of the module is still unchecked.

/**
 * XML-RPC callback : returns alphabar data.
 *
 * @return string
 *   The alphabar data, to be serialized in XML.
 */
function _g2_alphabar() {
  /** @var \Drupal\g2\Alphabar $alphabar */
  $alphabar = Drupal::service(G2::SVC_ALPHABAR);
  $ret = array_map(fn(GeneratedLink $link) => "$link", $alphabar->getLinks());
  return $ret;
}

/**
 * Log a hit from a referrer.
 *
 * Note that this does not work on cached pages, and will log hits from all
 * pages linking to a g2_entry, even if it is only from a block, not just from
 * the main content.
 *
 * @param \Drupal\Core\Entity\EntityInterface $node
 *   The node being viewed.
 */
function _g2_insert_referrer(EntityInterface $node): void {
  global $base_url;
  $referer = $_SERVER['HTTP_REFERER'] ?? '';
  if (empty($referer)) {
    return;
  }
  // For now, we do not handle non-local referers, which are no longer emitted
  // by modern (2025) browsers in most cases.
  if (!str_starts_with($referer, "${base_url}/")) {
    return;
  }

  // Extract local path, possibly aliased.
  $referer = mb_substr($referer, mb_strlen($base_url));
  // Unalias it.
  $referer = Drupal::service('path_alias.manager')->getPathByAlias($referer);
  // Sanitize it.
  $referer = Html::escape($referer);

  $sq = <<<SQL
UPDATE {g2_referer}
SET incoming = incoming + 1
WHERE nid = :nid AND referer = :referer;
SQL;
  $args = ['nid' => $node->id(), 'referer' => $referer];
  $stmt = Drupal::database()
    ->prepareStatement($sq, [], TRUE);
  $stmt->execute($args);
  if (!$stmt->rowCount()) {
    $sq = <<<SQL
INSERT INTO {g2_referer}
    (nid, referer, incoming)
VALUES (:nid, :referer, 1);
SQL;
    Drupal::database()->query($sq, $args);
  }
}

/**
 * XML-RPC callback : returns a list of the latest n nodes.
 *
 * "Latest" nodes are identified by time of latest update.
 *
 * @param int $count
 *   The maximum number of entries to return.
 *
 * @return array
 *   Note that the results are NOT filtered, and must be filtered when used.
 *
 * @throws \Drupal\Core\Entity\EntityMalformedException
 */
function _g2_latest(int $count = 0): array {
  $config = Drupal::config(G2::CONFIG_NAME);
  /** @var int $service_max */
  $service_max = $config->get(G2::VARLATESTMAXCOUNT);
  /** @var float $api_throttle */
  $api_throttle = $config->get(G2::VARAPITHROTTLE);
  $actual_max = (int) ceil($api_throttle * $service_max);

  // Limit extraction.
  if (empty($count) || ($count > $actual_max)) {
    $count = $actual_max;
  }

  /** @var \Drupal\g2\Latest $latest */
  $latest = Drupal::service(G2::SVC_LATEST);
  $links = $latest->getLinks($count);
  $result = [];

  /** @var \Drupal\Core\Link $link */
  foreach ($links as $link) {
    $result[] = "{$link->toString()}";
  }
  return $result;
}

/**
 * Extract statistics from the G2 glossary.
 *
 * @param int $tid
 *   Taxonomy term id
 * @param string $initial
 *   Initial segment
 *
 * @return array
 *   - g2 entries having chosen taxonomy term
 *   - g2 entries starting with chosen initial segment
 */
function _g2_stats(int $tid = 0, string $initial = ''): array {
  $db = Drupal::database();

  $qUnpub = $db->select('node', 'n');
  $unPubAlias = $qUnpub->innerJoin('node_field_data', 'nfd', 'nfd.nid = n.nid');
  $qUnpub
    ->condition('n.type', G2::BUNDLE)
    ->condition("${unPubAlias}.status", NodeInterface::NOT_PUBLISHED)
    ->addTag('node_access');

  $qPub = $db->select('node', 'n');
  $pubAlias = $qPub->innerJoin('node_field_data', 'nfd', 'nfd.nid = n.nid');
  $qPub
    ->condition('n.type', G2::BUNDLE)
    ->condition("${pubAlias}.status", NodeInterface::PUBLISHED)
    ->addTag('node_access');

  if (!empty($tid)) {
    $qUnpub->innerJoin('taxonomy_index', 'ti', 'n.nid = ti.nid');
    $qPub->innerJoin('taxonomy_index', 'ti', 'n.nid = ti.nid');
    $qUnpub = $qUnpub->condition('ti.tid', $tid);
    $qPub = $qPub->condition('ti.tid', $tid);
  }

  if (!empty($initial)) {
    $qUnpub = $qUnpub->condition("${unPubAlias}.title", "$initial%", 'LIKE');
    $qPub = $qPub->condition("${pubAlias}.title", "$initial%", 'LIKE');
  }

  $unpub = $qUnpub->countQuery()->execute();
  $pub = $qPub->countQuery()->execute();

  // Avoid empty returns
  $ret = [
    NodeInterface::NOT_PUBLISHED => $unpub->fetchField(),
    NodeInterface::PUBLISHED => $pub->fetchField()
  ];

  return $ret;
}

/**
 * Returns a list of the top n nodes as counted by statistics.module.
 *
 * - Unpublished nodes are not listed.
 * - Stickyness is ignored for ordering, but returned in the results for
 *   client-side ordering if needed.
 *
 * @param int|null $count
 *   Number or entries to return.
 * @param bool|null $daily_top
 *   Order by daily views if TRUE, otherwise by total views (default).
 *
 * @return array|null
 *   Statistics will empty without statistics module.
 *   Note that the title of the nodes is NOT filtered.
 */
function _g2_top($count = NULL, $daily_top = FALSE) {
  $config = Drupal::config(G2::CONFIG_NAME);
  $service_max = $config->get(G2::VARLATESTMAXCOUNT);
  $api_throttle = $config->get(G2::VARAPITHROTTLE);
  $actual_max = $api_throttle * $service_max;

  // Limit extraction.
  if (empty($count) || ($count > $actual_max)) {
    $count = $actual_max;
  }

  /** @var \Drupal\g2\Top $top */
  $top = Drupal::service('g2.top');
  $statistic = $daily_top ? Top::STATISTICS_DAY : Top::STATISTICS_TOTAL;
  $links = $top->getLinks($count, $statistic);
  $result = [];

  /** @var \Drupal\Core\GeneratedLink $link */
  foreach ($links as $link) {
    $result[] = $link->__toString();
  }
  return $result;
}

/**
 * Implements hook_theme().
 */
function g2_theme() {
  $config = Drupal::config(G2::CONFIG_NAME);
  $ret = [
    // Checked for D8/9/10.
    'g2_alphabar' => [
      'variables' => [
        'alphabar' => [],
        'row_length' => $config->get(G2::VARALPHABARROWLENGTH),
      ],
    ],
    // Checked for D8/9/10.
    'g2_entries' => [
      'variables' => [
        'raw_entry' => '',
        'entries' => [],
        'message' => NULL,
        'offer' => NULL,
      ],
    ],
    // Not checked
    'g2_initial' => [
      'variables' => [
        'initial' => NULL,
        'entries' => [],
      ],
    ],
    // Not checked
    'g2_main' => [
      'variables' => [
        'alphabar' => $config->get(G2::VARALPHABARCONTENTS),
        'text' => '',
      ],
    ],

    // --- Older versions ------------------------------------------------------
    'g2_random' => ['variables' => [G2::TYPE => NULL]],
    'g2_wotd' => ['variables' => [G2::TYPE => NULL]],
  ];
  return $ret;
}

/* ==== Code below this line has not yet been converted to D8 =============== */

/**
 * Remove tags from a taxonomy array for non-G2-admins.
 *
 * @param array $taxonomy
 *   An array of fully loaded terms (tid, vid, weight..)
 *
 * @return array
 *   The taxonomy terms, with tags removed if applicable.
 *
 * FIXME most likely redundant with view modes.
 */
function _g2_comb_taxonomy(array $taxonomy = []) {
  // Filter tag vocabularies for non-G2 admins if this is requested.
  if (variable_get(G2::VARNOFREETAGGING,
      G2::DEFNOFREETAGGING) && !user_access(G2::PERM_ADMIN)) {
    // No static cache here: there is already one in taxonomy_vocabulary_load().
    $vocabs = [];

    // We still hide the terms within freetagging vocabularies to allow partial
    // display.
    foreach ($taxonomy as $tid => $term) {
      // Is the vocabulary for the current term known ?
      $vid = $term->vid;
      if (!array_key_exists($vid, $vocabs)) {
        $vocab = taxonomy_vocabulary_load($vid);
        $vocabs[$vid] = $vocab->tags;
      }

      // If it's a tags vocab, hide its terms.
      if (!empty($vocabs[$vid])) {
        unset($taxonomy[$tid]);
      }
    }
  }

  return $taxonomy;
}

/**
 * Return a formatted set of terms as links.
 *
 * Return a span containing links to taxonomy terms, or nothing
 * if node information contains no terms. The "node" passed must
 * contain full term information, not just tids.
 *
 * @param object $node
 *   Imitation of a node.
 *
 * @return string
 *   The resulting string.
 */
function _g2_entry_terms($node) {
  $ret = NULL;
  if (!empty($node->taxonomy)) {
    $terms = [];
    foreach ($node->taxonomy as $tid => $term) {
      $terms[$tid] = [
        'href' => 'taxonomy/term/' . $term->tid,
        'title' => check_plain($term->name),
        'attributes' => ['rel' => 'tag'],
      ];
    }
    $ret = theme('links', $terms);
  }
  return $ret;
}

/**
 * Modify the default page title as built by Drupal.
 *
 * Tweaking $conf modifies only the live copy used by Drupal, not the stored
 * value as would be the case using variable_set.
 *
 * @see \Drupal\g2\Controller\Main::indexAction()
 */
function _g2_override_site_name() {
  if (variable_get(G2::VARPAGETITLE, G2::DEFPAGETITLE)) {
    global $conf;
    $conf['site_name'] = strtr(
      variable_get(G2::VARPAGETITLE, G2::DEFPAGETITLE),
      ['@title' => variable_get('site_name', 'Drupal')]
    );
  }
}

/**
 * Submit handler for _g2_referer_links().
 *
 * Use the wipe target to redirect to the wipe confirmation form. If we
 * hadn't been using a button for this link, we could just as well have
 * used a plain link.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function _g2_referer_links_submit(array &$form, FormStateInterface $form_state) {
  $form_state['redirect'] = 'g2/wipe/' . $form_state['values']['wipe_target'];
}

/**
 * Erase the referer counts on g2 entries.
 *
 * Difference from the 4.7 version: it no longer includes a goto when erasing
 * all.
 *
 * @param int $nid
 *   Node from which to erase referers, or NULL to erase all g2 referers.
 *
 * @FIXME 20090928 recheck
 */
function _g2_referer_wipe($nid = NULL) {
  if (isset($nid)) {
    $sq = 'DELETE from {g2_referer} WHERE nid = %d';
    Drupal::database()->query($sq, $nid);
    drupal_goto('node/' . $nid);
  }
  else {
    $sq = 'DELETE from {g2_referer}';
    Drupal::database()->query($sq);
  }
}

/**
 * Returns a structure for the WOTD.
 *
 * @param int $bodysize
 *   The maximum length for the body. Entails truncation.
 *
 * @return object
 *   Title / nid / teaser
 *   Teaser and Body are returned already filtered, not stripped.
 */
function _g2_wotd($bodysize = 0) {
  /** @var \Drupal\g2\WOTD $wotd */
  $wotd = \Drupal::service(G2::SVC_WOTD);
  $node = $wotd->get();
  if (empty($node)) {
    return NULL;
  }

  $node->teaser = check_markup($node->teaser, $node->format);

  $node->truncated = FALSE;
  if ($bodysize > 0) {
    // Save the raw version.
    $node->raw_body = $node->body;
    if (drupal_strlen($node->body) > $bodysize) {
      $node->truncated = TRUE;
      $body = drupal_substr($node->body, 0, $bodysize);
      $node->body = check_markup($body, $node->format);
    }
  }

  return $node;
}

/**
 * Implements hook_ENTITY_TYPE_access() for nodes.
 *
 * @throws \Drupal\Core\Entity\EntityMalformedException
 */
function g2_node_access(
  EntityInterface $node,
  string $op,
  AccountInterface $account
): AccessResultInterface {
  if ($node->bundle() != G2::BUNDLE) {
    return AccessResult::neutral("Not a G2 entry");
  }
  switch ($op) {
    case 'create':
    case 'delete':
    case 'update':
      return AccessResult::allowedIfHasPermission($account, G2::PERM_ADMIN);

    case 'view all revisions':
      return AccessResult::allowedIfHasPermission($account, 'view all revisions');

    case 'view':
      return AccessResult::allowedIfHasPermission($account, 'access content');

    default:
      \Drupal::logger(G2::NAME)
        ->notice('Node access for invalid op %op', [
          '%op' => $op,
          'link' => Link::fromTextAndUrl($node->label(), $node->toUrl())
            ->toRenderable(),
        ]);
      return AccessResult::neutral();
  }
}

/**
 * Implements hook_block().
 */
function g2_block($op = 'list', $delta = 0, $edit = []) {
  if ($op == 'configure') {
    switch ($delta) {
      case G2::DELTA_WOTD:
        $form['wotd_feed'] = [
          '#type' => 'fieldset',
          '#title' => t('RSS Feed'),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDLINK] = [
          '#type' => 'checkbox',
          '#title' => t('Display feed link'),
          '#default_value' => variable_get(G2::VARWOTDFEEDLINK,
            G2::DEFWOTDFEEDLINK),
          '#description' => t('Should the theme display the link to the RSS feed for this block ?'),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDTITLE] = [
          '#type' => 'textfield',
          '#title' => t('The feed title'),
          '#size' => 60,
          '#maxlength' => 60,
          '#required' => TRUE,
          '#default_value' => variable_get(G2::VARWOTDFEEDTITLE,
            variable_get(G2::VARWOTDTITLE, G2::DEFWOTDTITLE)),
          '#description' => t(
            'The title for the feed itself.
           This will typically be used by aggregators to remind users of the feed and link to it.
           If nulled, G2 will reset it to the title of the block.'
          ),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDAUTHOR] = [
          '#type' => 'textfield',
          '#title' => t('The feed item author'),
          '#size' => 60,
          '#maxlength' => 60,
          '#required' => TRUE,
          '#default_value' => variable_get(G2::VARWOTDFEEDAUTHOR,
            G2::DEFWOTDFEEDAUTHOR),
          '#description' => t(
            'The author name to be included in the feed entries.
        In this string @author will be replaced by the actual author information.'
          ),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDDESCR] = [
          '#type' => 'textfield',
          '#title' => t('The feed description'),
          '#size' => 60,
          '#maxlength' => 60,
          '#required' => TRUE,
          '#default_value' => variable_get(G2::VARWOTDFEEDDESCR,
            G2::DEFWOTDFEEDDESCR),
          '#description' => t(
            'The description for the feed itself.
        This will typically be used by aggregators when describing the feed prior to subscription.
        It may contain !site, which will dynamically be replaced by the site base URL.'
          ),
        ];
        break;

      default:
        break;
    }
    $ret = $form;
  }
  elseif ($op == 'save') {
    $ret = NULL;
    switch ($delta) {
      case G2::DELTA_WOTD:
        variable_set(G2::VARWOTDFEEDLINK, $edit[G2::VARWOTDFEEDLINK]);
        variable_set(G2::VARWOTDFEEDTITLE, $edit[G2::VARWOTDFEEDTITLE]);
        variable_set(G2::VARWOTDFEEDDESCR, $edit[G2::VARWOTDFEEDDESCR]);
        variable_set(G2::VARWOTDFEEDAUTHOR, $edit[G2::VARWOTDFEEDAUTHOR]);
        break;

      default:
        break;
    }
  }

  return $ret;
}

/**
 * Loader for G2_entries.
 *
 * Only returns unpublished nodes to users with "administer nodes".
 *
 * @param string $title
 *   The title to look for.
 *
 * @return array
 *   Nodes matching the title.
 *
 * @see \Drupal\g2\Plugin\Filter\Definition::doProcess
 */
function g2_entry_load(string $title) {
  $storage = \Drupal::entityTypeManager()->getStorage(G2::TYPE);
  $nids = $storage->getQuery()
    ->accessCheck()
    ->condition('type', G2::BUNDLE)
    ->condition('status', NodeInterface::PUBLISHED)
    ->condition('title', $title)
    ->execute();
  if (empty($nids)) {
    return [];
  }

  $nodes = $storage->loadMultiple($nids);
  return $nodes;
}

/**
 * Menu loader for g2_node.
 *
 * @param int $us_nid
 *   The id of the node to load.
 *
 * @return object|false|null
 *   The load result.
 */
function g2_node_load($us_nid = 0) {
  // Safety with regard to $us_nid is checked within node_load()
  if (is_numeric($us_nid)) {
    $node = Drupal::entityTypeManager()
      ->getStorage(G2::TYPE)
      ->load($us_nid);
  }
  else {
    $node = reset($us_nid);
  }
  if ($node->getEntityTypeId() != G2::BUNDLE) {
    $node = NULL;
  }

  return $node;
}

/**
 * Submit handler for "wipe referers" button.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function g2_referer_wipe_button_submit(
  array $form,
  FormStateInterface $form_state
) {
  drupal_goto('g2/wipe');
}

/**
 * Form builder for the referer wipe confirmation request form.
 *
 * This is the same form for both global wipe and individual node wipe.
 *
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 * @param null|\Drupal\node\NodeInterface $node
 *   The node from which to erase.
 *
 * @return array
 *   A render array for the confirm form.
 */
function g2_referer_wipe_confirm_form(
  FormStateInterface $form_state,
  NodeInterface $node = NULL
) {
  $form = [];

  if (is_object($node) && isset($node->nid)) {
    $question = t('Are you sure to want to erase the referer information on this G2 entry ?');
    $cancel = 'node/' . $node->nid . '/referers';
    $form[G2::TYPE] = [
      '#prefix' => '<p><em>',
      '#value' => check_plain($node->title),
      '#suffix' => '</em></p>',
    ];
  }
  else {
    $question = t('Are you sure to want to erase the referer information on all G2 entries ?');
    $cancel = G2::PATH_SETTINGS;
  }

  $ret = confirm_form(
    $form,
    $question,
    $cancel,
    t('This action cannot be undone.'),
    t('Confirm'),
    t('Cancel')
  );
  return $ret;
}

/**
 * Submit handler for referer wipe confirmation.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function g2_referer_wipe_confirm_form_submit(array $form, FormStateInterface $form_state) {
  _g2_referer_wipe();
  Drupal::messenger()
    ->addStatus(t('Referer information has been erased on all G2 entries'));
  $form_state['redirect'] = G2::PATH_SETTINGS;
}

/**
 * Implements hook_user().
 *
 * @todo D6 check when content is actually there
 */
function g2_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'load':
      // Issue #1047248: unused n.changed and n.created columns are for PGSQL.
      $sq = <<<SQL
SELECT n.nid, n.title, n.changed, n.created
FROM {node} n
WHERE n.type = '%s' AND n.status  = 1 AND n.uid = %d
ORDER BY n.changed DESC, n.created DESC;
SQL;
      $sq = db_rewrite_sql($sq);
      $q = db_query_range($sq, G2::BUNDLE, $account->uid, 0, 10);
      $account->nodes = [];
      while (is_object($o = db_fetch_object($q))) {
        $account->nodes[] = [
          'value' => l($o->title, 'node/' . $o->nid, ['absolute' => TRUE]),
        ];
      }
      break;

    case 'view':
      $nodes = [];
      if (is_array($account->nodes)) {
        foreach ($account->nodes as $node) {
          $nodes[] = $node['value'];
        }
      }
      $account->content['summary']['g2'] = [
        '#type' => 'user_profile_item',
        '#title' => t('Owned G2 definitions'),
        '#value' => theme('item_list', $nodes),
        '#description' => t('10 most recently changed only'),
      ];
      break;

    default:
      break;
  }
}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function g2_node_view(array &$build, EntityInterface $node, EntityViewDisplayInterface $display, $view_mode) {
  if ($node->bundle() != G2::BUNDLE) {
    return;
  }
  $config = Drupal::config(G2::CONFIG_NAME);

  // On the WOTD feed, force the node date to the WOTD date or current time.
  if ($view_mode === G2::VM_RSS &&
    Drupal::routeMatch()->getRouteName() === G2::ROUTE_FEED_WOTD) {
    $node->created = (Drupal::state()->get(G2::VARWOTDDATE) ?: time());
  }

  if ($config->get(G2::VARLOGREFERRERS)) {
    _g2_insert_referrer($node);
  }

  return $node;
}

/**
 * Implements hook_views_api().
 */
function g2_views_api() {
  return [
    'api' => '2.0',
    'path' => ExtensionPathResolver::getPath('module', 'g2') . '/views',
  ];
}

/**
 * Theme a random entry.
 *
 * This is actually a short view for just about any single node, but it
 * is even shorter than node_view($node, TRUE).
 *
 * @param object $node
 *   A node to display.
 *
 * @return string
 *   HTML: the themed entry.
 */
function theme_g2_random($node = NULL) {
  $ret = l($node->title, 'node/' . $node->nid);
  if ($node->teaser) {
    // Why t() ? Because varying languages have varying takes on spaces
    // before/after semicolons.
    $ret .= t(': @teaser', ['@teaser' => $node->teaser]);
  }
  // No need to test: also works on missing taxonomy.
  $ret .= _g2_entry_terms($node);
  $ret .= theme('more_link', url('node/' . $node->nid), t('&nbsp;(+)'));
  return $ret;
}

/**
 * Theme a WOTD block.
 *
 * @param \Drupal\node\Entity\Node|null $node
 *   The node for the word of the day. teaser and body are already filtered and
 *   truncated if needed.
 *
 * @return string
 *   Title / nid / teaser / [body].
 */
function theme_g2_wotd(Node $node = NULL) {
  if (empty($node)) {
    return NULL;
  }

  // l() check_plain's text.
  $link = l($node->title, 'node/' . $node->nid);
  if (isset($node->teaser) and !empty($node->teaser)) {
    // Teaser already filtered by _g2_wotd(), don't filter twice.
    $teaser = '<span id="g2_wotd_teaser">' . strip_tags($node->teaser) . '</span>';
    $ret = t(
      '!link: !teaser',
      [
        '!link' => $link,
        '!teaser' => $teaser,
      ]
    );
    unset($teaser);
  }
  else {
    $ret = $link;
  }

  if (!empty($node->body)) {
    // Already filtered by _g2_wotd(), don't filter twice, just strip.
    $body = strip_tags($node->body);
    if ($node->truncated) {
      $body .= '&hellip;';
    }
    $ret .= '<div id="g2_wotd_body">' . $body . '</div>';
  }
  $node->taxonomy = _g2_comb_taxonomy($node->taxonomy);
  // No need to test: it won't change anything if no taxonomy was returned.
  $ret .= _g2_entry_terms($node);
  $ret .= theme('more_link', url('node/' . $node->nid), t('&nbsp;(+)'));
  if (variable_get(G2::VARWOTDFEEDLINK, G2::DEFWOTDFEEDLINK)) {
    $ret .= theme(
      'feed_icon',
      url(G2::ROUTE_FEED_WOTD, ['absolute' => TRUE]),
      t('A word a day in your RSS reader')
    );
  }

  return $ret;
}
