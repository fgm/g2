<?php

/**
 * @file
 * This defines a node-based glossary module, vs the term-based glossary.
 *
 * @todo Test wipes, rss
 *
 * @todo For D8, in decreasing priorities
 *  - implement SettingsForm::validateForm() using Requirements
 *  - make g2_requirements() less verbose, at least on success.
 *  - find a way to add the title to the node.add route for ease of creation.
 * @copyright 2005-2023 Frédéric G. Marand, for Ouest Systemes Informatiques.
 *
 * @link http://wiki.audean.com/g2/choosing @endlink
 */

declare(strict_types = 1);

use Drupal\Component\Utility\Html;
use Drupal\Core\Entity\Entity\EntityViewMode;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\GeneratedLink;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\g2\G2;
use Drupal\g2\Top;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\views\ViewExecutable;

/**
 * Implements hook_cron().
 *
 * In G2's case, change the WOTD once a day if this feature is enabled,
 * which is the default case.
 */
function g2_cron() {
  /** @var \Drupal\g2\WOTD $wotd */
  $wotd = \Drupal::service(G2::SVC_WOTD);
  $wotd->cron();
}

/**
 * Implements hook_help().
 */
function g2_help($route_name, RouteMatchInterface $route_match) {
  $result = '';
  switch ($route_name) {
    case 'help.page.g2':
      $result = t(
        '<p>G2 defines a glossary service for Drupal sites.
       To compare it with the Glossary and Lexicon modules:</p>
       <ul>
         <li>G2 content is node-based, not term-based, allowing node access control</li>
         <li>G2 leverages existing code from glossary for input filtering and node marking</li>
         <li>G2 RAM use does not significantly increase with larger entry counts, which makes is more suitable for larger glossaries</li>
         <li>G2 requests much less from the database than the default glossary</li>
         <li>G2 uses a "G2 Context" taxonomy vocabulary by default, but does not require it.</li>
         <li>G2 defines optional blocks</li>
         <li>G2 provides a client and server XML-RPC API</li>
         <li>G2 does not provide term feeds</li>
         </ul>'
      );
      break;

    case 'entity.block.edit_form':
      // G2 block plugins contain a "help" annotation.
      $definition = $route_match
        ->getParameter('block')
        ->getPlugin()
        ->getPluginDefinition();
      if ($definition['provider'] !== 'g2') {
        return NULL;
      }
      $result = $definition['help'] ?? '';
      break;

    case 'entity.entity_view_display.node.view_mode':
      if ($route_match->getParameter('entity_type_id') != G2::TYPE) {
        break;
      }
      if ($route_match->getParameter('bundle') !== G2::BUNDLE) {
        break;
      }
      $name = $route_match->getParameter('view_mode_name');
      $args = ['%vm' => EntityViewMode::load(G2::TYPE . ".${name}")->label()];
      switch ($name) {
        case G2::VM_BLOCK:
          $result = t('The %vm display is used by the G2 Random and WOTD blocks.', $args);
          break;

        case G2::VM_ENTRY_LIST:
          $result = t('The %vm display is used by the G2 "terms by initial" page and the homonyms page in "plain node list" mode.', $args);
          break;

        case G2::VM_HOMONYMS_PAGE:
          $result = t('The %vm display is used by the G2 homonyms disambiguation page when it is configured to use a node (which is deprecated) instead of a route.', $args);
          break;

        case G2::VM_TOOLTIPS:
          $result = t('The %vm display is used by the G2 definition filter when tooltips are configured to use teasers');
          break;
      }
      if (!empty($result)) {
        $result = ['#markup' => "<p>${result}</p>\n"];
      }
  }

  return $result;
}

/**
 * Implements hook_ENTITY_TYPE_delete() for nodes.
 */
function g2_node_delete(NodeInterface $node) {
  /** @var \Drupal\g2\Matcher $matcher */
  $matcher = Drupal::service(G2::SVC_MATCHER);
  $matcher->rebuild();
}

/**
 * Implements hook_ENTITY_TYPE_insert() for nodes.
 */
function g2_node_insert(NodeInterface $node) {
  /** @var \Drupal\g2\Matcher $matcher */
  $matcher = Drupal::service(G2::SVC_MATCHER);
  $matcher->rebuild();
}

/**
 * Implements hook_ENTITY_TYPE_update() for nodes.
 */
function g2_node_update(NodeInterface $node) {
  /** @var \Drupal\g2\Matcher $matcher */
  $matcher = Drupal::service(G2::SVC_MATCHER);
  $matcher->rebuild();
}

/**
 * Implements hook_preprocess_views_view_rss().
 */
function g2_preprocess_views_view_rss(&$variables) {
  /** @var \Drupal\g2\WOTD $wotd */
  $wotd = Drupal::service(G2::SVC_WOTD);
  $wotd->preprocessViewsViewRss($variables);
}

/**
 * Implements hook_views_pre_render().
 */
function g2_views_pre_render(ViewExecutable $view) {
  if ($view->id() === G2::VIEW_WOTD && $view->current_display === G2::VIEW_WOTD_DISPLAY) {
    /** @var \Drupal\g2\WOTD $wotd */
    $wotd = Drupal::service(G2::SVC_WOTD);
    $wotd->viewsPreRender($view);
  }
}

/* Code in this part of the module works in D10/9 but may not be finalized. */

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function g2_node_view(array &$build, NodeInterface $node) {
  if ($node->bundle() != G2::BUNDLE) {
    return;
  }
  $config = Drupal::config(G2::CONFIG_NAME);

  if ($config->get(G2::VARLOGREFERRERS)) {
    _g2_insert_referrer($node);
  }

  return $node;
}

/**
 * Implements hook_xmlrpc().
 *
 * Note that functions returning node portions return them unfiltered.
 * It is the caller's responsibility to apply filtering depending on
 * its actual use of the data.
 */
function g2_xmlrpc() {
  $mapping = [
    // D10/9 OK.
    'g2.alphabar' => '_g2_alphabar',
    'g2.api' => [G2::class, 'api'],
    'g2.latest' => '_g2_latest',
    'g2.stats' => '_g2_stats',
    'g2.top' => '_g2_top',

    // D10/9 exception.
    'g2.random' => [\Drupal::service(G2::SVC_RANDOM), 'get'],
    'g2.wotd' => '_g2_wotd',
  ];

  $enabled = Drupal::config(G2::CONFIG_NAME)->get(G2::VARAPIENABLED);
  if (!$enabled) {
    $mapping = [];
  }

  return $mapping;
}

/* Code in this part of the module is still unchecked. */

/**
 * XML-RPC callback : returns alphabar data.
 *
 * @return string
 *   The alphabar data, to be serialized in XML.
 */
function _g2_alphabar() {
  /** @var \Drupal\g2\Alphabar $alphabar */
  $alphabar = Drupal::service(G2::SVC_ALPHABAR);
  $ret = array_map(fn(GeneratedLink $link) => "$link", $alphabar->getLinks());
  return $ret;
}

/**
 * Log a hit from a referrer.
 *
 * Note that this does not work on cached pages, and will log hits from all
 * pages linking to a g2_entry, even if it is only from a block, not just from
 * the main content.
 *
 * @param \Drupal\Core\Entity\EntityInterface $node
 *   The node being viewed.
 */
function _g2_insert_referrer(EntityInterface $node): void {
  global $base_url;
  $referer = $_SERVER['HTTP_REFERER'] ?? '';
  if (empty($referer)) {
    return;
  }
  // For now, we do not handle non-local referers, which are no longer emitted
  // by modern (2025) browsers in most cases.
  if (!str_starts_with($referer, "${base_url}/")) {
    return;
  }

  // Extract local path, possibly aliased.
  $referer = mb_substr($referer, mb_strlen($base_url));
  // Unalias it.
  $referer = Drupal::service('path_alias.manager')->getPathByAlias($referer);
  // Sanitize it.
  $referer = Html::escape($referer);

  $sq = <<<SQL
UPDATE {g2_referer}
SET incoming = incoming + 1
WHERE nid = :nid AND referer = :referer;
SQL;
  $args = ['nid' => $node->id(), 'referer' => $referer];
  $stmt = Drupal::database()
    ->prepareStatement($sq, [], TRUE);
  $stmt->execute($args);
  if (!$stmt->rowCount()) {
    $sq = <<<SQL
INSERT INTO {g2_referer}
    (nid, referer, incoming)
VALUES (:nid, :referer, 1);
SQL;
    Drupal::database()->query($sq, $args);
  }
}

/**
 * XML-RPC callback : returns a list of the latest n nodes.
 *
 * "Latest" nodes are identified by time of latest update.
 *
 * @param int $count
 *   The maximum number of entries to return.
 *
 * @return array
 *   Note that the results are NOT filtered, and must be filtered when used.
 *
 * @throws \Drupal\Core\Entity\EntityMalformedException
 */
function _g2_latest(int $count = 0): array {
  $config = Drupal::config(G2::CONFIG_NAME);
  /** @var int $service_max */
  $service_max = $config->get(G2::VARLATESTMAXCOUNT);
  /** @var float $api_throttle */
  $api_throttle = $config->get(G2::VARAPITHROTTLE);
  $actual_max = (int) ceil($api_throttle * $service_max);

  // Limit extraction.
  if (empty($count) || ($count > $actual_max)) {
    $count = $actual_max;
  }

  /** @var \Drupal\g2\Latest $latest */
  $latest = Drupal::service(G2::SVC_LATEST);
  $links = $latest->getLinks($count);
  $result = [];

  /** @var \Drupal\Core\Link $link */
  foreach ($links as $link) {
    $result[] = "{$link->toString()}";
  }
  return $result;
}

/**
 * Extract statistics from the G2 glossary.
 *
 * @param int $tid
 *   Taxonomy term id.
 * @param string $initial
 *   Initial segment.
 *
 * @return array
 *   - g2 entries having chosen taxonomy term
 *   - g2 entries starting with chosen initial segment
 */
function _g2_stats(int $tid = 0, string $initial = ''): array {
  $db = Drupal::database();

  $qUnpub = $db->select('node', 'n');
  $unPubAlias = $qUnpub->innerJoin('node_field_data', 'nfd', 'nfd.nid = n.nid');
  $qUnpub
    ->condition('n.type', G2::BUNDLE)
    ->condition("${unPubAlias}.status", NodeInterface::NOT_PUBLISHED)
    ->addTag('node_access');

  $qPub = $db->select('node', 'n');
  $pubAlias = $qPub->innerJoin('node_field_data', 'nfd', 'nfd.nid = n.nid');
  $qPub
    ->condition('n.type', G2::BUNDLE)
    ->condition("${pubAlias}.status", NodeInterface::PUBLISHED)
    ->addTag('node_access');

  if (!empty($tid)) {
    $qUnpub->innerJoin('taxonomy_index', 'ti', 'n.nid = ti.nid');
    $qPub->innerJoin('taxonomy_index', 'ti', 'n.nid = ti.nid');
    $qUnpub = $qUnpub->condition('ti.tid', $tid);
    $qPub = $qPub->condition('ti.tid', $tid);
  }

  if (!empty($initial)) {
    $qUnpub = $qUnpub->condition("${unPubAlias}.title", "$initial%", 'LIKE');
    $qPub = $qPub->condition("${pubAlias}.title", "$initial%", 'LIKE');
  }

  $unpub = $qUnpub->countQuery()->execute();
  $pub = $qPub->countQuery()->execute();

  // Avoid empty returns.
  $ret = [
    NodeInterface::NOT_PUBLISHED => $unpub->fetchField(),
    NodeInterface::PUBLISHED => $pub->fetchField(),
  ];

  return $ret;
}

/**
 * Returns a list of the top n nodes as counted by statistics.module.
 *
 * - Unpublished nodes are not listed.
 * - Stickyness is ignored for ordering, but returned in the results for
 *   client-side ordering if needed.
 *
 * @param int|null $count
 *   Number or entries to return.
 * @param bool|null $daily_top
 *   Order by daily views if TRUE, otherwise by total views (default).
 *
 * @return array|null
 *   Statistics will empty without statistics module.
 *   Note that the title of the nodes is NOT filtered.
 */
function _g2_top($count = NULL, $daily_top = FALSE) {
  $config = Drupal::config(G2::CONFIG_NAME);
  $service_max = $config->get(G2::VARLATESTMAXCOUNT);
  $api_throttle = $config->get(G2::VARAPITHROTTLE);
  $actual_max = $api_throttle * $service_max;

  // Limit extraction.
  if (empty($count) || ($count > $actual_max)) {
    $count = $actual_max;
  }

  /** @var \Drupal\g2\Top $top */
  $top = Drupal::service('g2.top');
  $statistic = $daily_top ? Top::STATISTICS_DAY : Top::STATISTICS_TOTAL;
  $links = $top->getLinks($count, $statistic);
  $result = [];

  /** @var \Drupal\Core\GeneratedLink $link */
  foreach ($links as $link) {
    $result[] = $link->__toString();
  }
  return $result;
}

/**
 * Implements hook_theme().
 */
function g2_theme() {
  $config = Drupal::config(G2::CONFIG_NAME);
  $ret = [
    // Checked for D8/9/10.
    'g2_alphabar' => [
      'variables' => [
        'alphabar' => [],
        'row_length' => $config->get(G2::VARALPHABARROWLENGTH),
      ],
    ],
    // Checked for D8/9/10.
    'g2_entries' => [
      'variables' => [
        'raw_entry' => '',
        'entries' => [],
        'message' => NULL,
        'offer' => NULL,
      ],
    ],
    // Not checked.
    'g2_initial' => [
      'variables' => [
        'initial' => NULL,
        'entries' => [],
      ],
    ],
    // Not checked.
    'g2_main' => [
      'variables' => [
        'alphabar' => $config->get(G2::VARALPHABARCONTENTS),
        'text' => '',
      ],
    ],

    // --- Older versions ------------------------------------------------------
    'g2_random' => ['variables' => [G2::TYPE => NULL]],
  ];
  return $ret;
}

/* ==== Code below this line has not yet been converted to D8 =============== */

/**
 * Remove tags from a taxonomy array for non-G2-admins.
 *
 * @param array $taxonomy
 *   An array of fully loaded terms (tid, vid, weight..)
 *
 * @return array
 *   The taxonomy terms, with tags removed if applicable.
 *
 *   FIXME most likely redundant with view modes.
 */
function _g2_comb_taxonomy(array $taxonomy = []) {
  // Filter tag vocabularies for non-G2 admins if this is requested.
  if (variable_get(G2::VARNOFREETAGGING,
      G2::DEFNOFREETAGGING) && !user_access(G2::PERM_ADMIN)) {
    // No static cache here: there is already one in taxonomy_vocabulary_load().
    $vocabs = [];

    // We still hide the terms within freetagging vocabularies to allow partial
    // display.
    foreach ($taxonomy as $tid => $term) {
      // Is the vocabulary for the current term known ?
      $vid = $term->vid;
      if (!array_key_exists($vid, $vocabs)) {
        $vocab = taxonomy_vocabulary_load($vid);
        $vocabs[$vid] = $vocab->tags;
      }

      // If it's a tags vocab, hide its terms.
      if (!empty($vocabs[$vid])) {
        unset($taxonomy[$tid]);
      }
    }
  }

  return $taxonomy;
}

/**
 * Return a formatted set of terms as links.
 *
 * Return a span containing links to taxonomy terms, or nothing
 * if node information contains no terms. The "node" passed must
 * contain full term information, not just tids.
 *
 * @param object $node
 *   Imitation of a node.
 *
 * @return string
 *   The resulting string.
 */
function _g2_entry_terms($node) {
  $ret = NULL;
  if (!empty($node->taxonomy)) {
    $terms = [];
    foreach ($node->taxonomy as $tid => $term) {
      $terms[$tid] = [
        'href' => 'taxonomy/term/' . $term->tid,
        'title' => check_plain($term->name),
        'attributes' => ['rel' => 'tag'],
      ];
    }
    $ret = theme('links', $terms);
  }
  return $ret;
}

/**
 * Submit handler for _g2_referer_links().
 *
 * Use the wipe target to redirect to the wipe confirmation form. If we
 * hadn't been using a button for this link, we could just as well have
 * used a plain link.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function _g2_referer_links_submit(array &$form, FormStateInterface $form_state) {
  $form_state['redirect'] = 'g2/wipe/' . $form_state['values']['wipe_target'];
}

/**
 * Erase the referer counts on g2 entries.
 *
 * Difference from the 4.7 version: it no longer includes a goto when erasing
 * all.
 *
 * @param int $nid
 *   Node from which to erase referers, or NULL to erase all g2 referers.
 *
 * @FIXME 20090928 recheck
 */
function _g2_referer_wipe($nid = NULL) {
  if (isset($nid)) {
    $sq = 'DELETE from {g2_referer} WHERE nid = %d';
    Drupal::database()->query($sq, $nid);
    drupal_goto('node/' . $nid);
  }
  else {
    $sq = 'DELETE from {g2_referer}';
    Drupal::database()->query($sq);
  }
}

/**
 * Returns a structure for the WOTD.
 *
 * @param int $bodysize
 *   The maximum length for the body. Entails truncation.
 *
 * @return object
 *   Title / nid / teaser
 *   Teaser and Body are returned already filtered, not stripped.
 */
function _g2_wotd($bodysize = 0) {
  /** @var \Drupal\g2\WOTD $wotd */
  $wotd = \Drupal::service(G2::SVC_WOTD);
  $node = $wotd->get();
  if (empty($node)) {
    return NULL;
  }

  $node->teaser = check_markup($node->teaser, $node->format);

  $node->truncated = FALSE;
  if ($bodysize > 0) {
    // Save the raw version.
    $node->raw_body = $node->body;
    if (drupal_strlen($node->body) > $bodysize) {
      $node->truncated = TRUE;
      $body = drupal_substr($node->body, 0, $bodysize);
      $node->body = check_markup($body, $node->format);
    }
  }

  return $node;
}

/**
 * Implements hook_block().
 */
function g2_block($op = 'list', $delta = 0, $edit = []) {
  if ($op == 'configure') {
    switch ($delta) {
      case G2::DELTA_WOTD:
        $form['wotd_feed'] = [
          '#type' => 'fieldset',
          '#title' => t('RSS Feed'),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDLINK] = [
          '#type' => 'checkbox',
          '#title' => t('Display feed link'),
          '#default_value' => variable_get(G2::VARWOTDFEEDLINK,
            G2::DEFWOTDFEEDLINK),
          '#description' => t('Should the theme display the link to the RSS feed for this block ?'),
        ];
        break;

      default:
        break;
    }
    $ret = $form;
  }
  elseif ($op == 'save') {
    $ret = NULL;
    switch ($delta) {
      case G2::DELTA_WOTD:
        variable_set(G2::VARWOTDFEEDLINK, $edit[G2::VARWOTDFEEDLINK]);
        break;
    }
  }

  return $ret;
}

/**
 * Loader for G2_entries.
 *
 * Only returns unpublished nodes to users with "administer nodes".
 *
 * @param string $title
 *   The title to look for.
 *
 * @return array
 *   Nodes matching the title.
 *
 * @see \Drupal\g2\Plugin\Filter\Definition::doProcess
 */
function g2_entry_load(string $title) {
  $storage = \Drupal::entityTypeManager()->getStorage(G2::TYPE);
  $nids = $storage->getQuery()
    ->accessCheck()
    ->condition('type', G2::BUNDLE)
    ->condition('status', NodeInterface::PUBLISHED)
    ->condition('title', $title)
    ->execute();
  if (empty($nids)) {
    return [];
  }

  $nodes = $storage->loadMultiple($nids);
  return $nodes;
}

/**
 * Menu loader for g2_node.
 *
 * @param int $us_nid
 *   The id of the node to load.
 *
 * @return object|false|null
 *   The load result.
 */
function g2_node_load($us_nid = 0) {
  // Safety with regard to $us_nid is checked within node_load()
  if (is_numeric($us_nid)) {
    $node = Drupal::entityTypeManager()
      ->getStorage(G2::TYPE)
      ->load($us_nid);
  }
  else {
    $node = reset($us_nid);
  }
  if ($node->getEntityTypeId() != G2::BUNDLE) {
    $node = NULL;
  }

  return $node;
}

/**
 * Implements hook_preprocess_html().
 *
 * Append the glossary name to the page title on entry pages and G2 own pages,
 * possibly including the default site name.
 */
function g2_preprocess_html(&$variables) {
  if (!\Drupal::service(G2::SVC_ROUTE_FILTER)->isG2Route()) {
    return;
  }
  $override = \Drupal::config(G2::CONFIG_NAME)
    ->get(G2::VARPAGETITLE);
  if (empty($override)) {
    return;
  }
  $name = strtr($override, ['@title' => $variables['head_title']['name']]);
  $variables['head_title']['name'] = $name;
}

/**
 * Submit handler for "wipe referers" button.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function g2_referer_wipe_button_submit(
  array $form,
  FormStateInterface $form_state
) {
  drupal_goto('g2/wipe');
}

/**
 * Form builder for the referer wipe confirmation request form.
 *
 * This is the same form for both global wipe and individual node wipe.
 *
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 * @param null|\Drupal\node\NodeInterface $node
 *   The node from which to erase.
 *
 * @return array
 *   A render array for the confirm form.
 */
function g2_referer_wipe_confirm_form(
  FormStateInterface $form_state,
  NodeInterface $node = NULL
) {
  $form = [];

  if (is_object($node) && isset($node->nid)) {
    $question = t('Are you sure to want to erase the referer information on this G2 entry ?');
    $cancel = 'node/' . $node->nid . '/referers';
    $form[G2::TYPE] = [
      '#prefix' => '<p><em>',
      '#value' => check_plain($node->title),
      '#suffix' => '</em></p>',
    ];
  }
  else {
    $question = t('Are you sure to want to erase the referer information on all G2 entries ?');
    $cancel = G2::PATH_SETTINGS;
  }

  $ret = confirm_form(
    $form,
    $question,
    $cancel,
    t('This action cannot be undone.'),
    t('Confirm'),
    t('Cancel')
  );
  return $ret;
}

/**
 * Submit handler for referer wipe confirmation.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function g2_referer_wipe_confirm_form_submit(array $form, FormStateInterface $form_state) {
  _g2_referer_wipe();
  Drupal::messenger()
    ->addStatus(t('Referer information has been erased on all G2 entries'));
  $form_state['redirect'] = G2::PATH_SETTINGS;
}

/**
 * Implements hook_user().
 *
 * @todo D6 check when content is actually there
 */
function g2_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'load':
      // Issue #1047248: unused n.changed and n.created columns are for PGSQL.
      $sq = <<<SQL
SELECT n.nid, n.title, n.changed, n.created
FROM {node} n
WHERE n.type = '%s' AND n.status  = 1 AND n.uid = %d
ORDER BY n.changed DESC, n.created DESC;
SQL;
      $sq = db_rewrite_sql($sq);
      $q = db_query_range($sq, G2::BUNDLE, $account->uid, 0, 10);
      $account->nodes = [];
      while (is_object($o = db_fetch_object($q))) {
        $account->nodes[] = [
          'value' => l($o->title, 'node/' . $o->nid, ['absolute' => TRUE]),
        ];
      }
      break;

    case 'view':
      $nodes = [];
      if (is_array($account->nodes)) {
        foreach ($account->nodes as $node) {
          $nodes[] = $node['value'];
        }
      }
      $account->content['summary']['g2'] = [
        '#type' => 'user_profile_item',
        '#title' => t('Owned G2 definitions'),
        '#value' => theme('item_list', $nodes),
        '#description' => t('10 most recently changed only'),
      ];
      break;

    default:
      break;
  }
}

/**
 * Theme a random entry.
 *
 * This is actually a short view for just about any single node, but it
 * is even shorter than node_view($node, TRUE).
 *
 * @param object $node
 *   A node to display.
 *
 * @return string
 *   HTML: the themed entry.
 */
function theme_g2_random($node = NULL) {
  $ret = l($node->title, 'node/' . $node->nid);
  if ($node->teaser) {
    // Why t() ? Because varying languages have varying takes on spaces
    // before/after semicolons.
    $ret .= t(': @teaser', ['@teaser' => $node->teaser]);
  }
  // No need to test: also works on missing taxonomy.
  $ret .= _g2_entry_terms($node);
  $ret .= theme('more_link', url('node/' . $node->nid), t('&nbsp;(+)'));
  return $ret;
}
