<?php

/**
 * @file
 * This defines a node-based glossary module, vs the term-based glossary.
 *
 * @todo Test wipes, rss
 *
 * @todo For D8, in decreasing priorities
 *  - implement SettingsForm::validateForm() using Requirements
 *  - make g2_requirements() less verbose, at least on success.
 *  - find a way to add the title to the node.add route for ease of creation.
 * @copyright 2005-2023 Frédéric G. Marand, for Ouest Systemes Informatiques.
 *
 * @link http://wiki.audean.com/g2/choosing @endlink
 */

use Drupal\Component\Utility\Html;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\Entity\EntityViewMode;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Extension\ExtensionPathResolver;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\GeneratedLink;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\g2\G2;
use Drupal\g2\Top;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;

/**
 * XML-RPC callback : returns alphabar data.
 *
 * @return string
 *   The alphabar data, to be serialized in XML.
 */
function _g2_alphabar() {
  /** @var \Drupal\g2\Alphabar $alphabar */
  $alphabar = Drupal::service(G2::SVC_ALPHABAR);
  $ret = array_map(fn(GeneratedLink $link) => "$link", $alphabar->getLinks());
  return $ret;
}

/**
 * XML-RPC callback : returns the current XML-RPC API version.
 *
 * @return int
 *   The G2 XML-RPC API major version.
 */
function _g2_api() {
  return G2::api();
}

/**
 * Log a hit from a referrer.
 *
 * Note that this does not work on cached pages, and will log hits from all
 * pages linking to a g2_entry, even if it is only from a block, not just from
 * the main content.
 *
 * @param \Drupal\Core\Entity\EntityInterface $node
 *   The node being viewed.
 */
function _g2_insert_referrer(EntityInterface $node): void {
  global $base_url;
  $referer = $_SERVER['HTTP_REFERER'] ?? '';
  if (empty($referer)) {
    return;
  }
  // For now, we do not handle non-local referers, which are no longer emitted
  // by modern (2025) browsers in most cases.
  if (!str_starts_with($referer, $base_url . '/')) {
    return;
  }

  // Extract local path, possibly aliased.
  $referer = mb_substr($referer, mb_strlen($base_url) + 1);
  // Unalias it.
  $referer = Drupal::service('path_alias.manager')->getPathByAlias($referer);
  // Sanitize it.
  $referer = Html::escape($referer);

  $sq = <<<SQL
UPDATE {g2_referer}
SET incoming = incoming + 1
WHERE nid = :nid AND referer = :referer;
SQL;
  $args = ['nid' => $node->id(), 'referer' => $referer];
  $stmt = Drupal::database()
    ->prepareStatement($sq, [], TRUE);
  $stmt->execute($args);
  if (!$stmt->rowCount()) {
    $sq = <<<SQL
INSERT INTO {g2_referer}
    (nid, referer, incoming)
VALUES (:nid, :referer, 1);
SQL;
    Drupal::database()->query($sq, $args);
  }
}

/**
 * XML-RPC callback : returns a list of the latest n nodes.
 *
 * "Latest" nodes are identified by time of latest update.
 *
 * @param int|null $count
 *   The maximum number of entries to return.
 *
 * @return array
 *   Note that the results are NOT filtered, and must be filtered when used.
 */
function _g2_latest($count = NULL) {
  $config = Drupal::config('g2.settings');
  $service_max = $config->get('services.latest.max_count');
  $api_throttle = $config->get('api.server.throttle');
  $actual_max = $api_throttle * $service_max;

  // Limit extraction.
  if (empty($count) || ($count > $actual_max)) {
    $count = $actual_max;
  }

  /** @var \Drupal\g2\Latest $latest */
  $latest = Drupal::service('g2.latest');
  $links = $latest->getLinks($count);
  $result = [];

  /** @var \Drupal\Core\GeneratedLink $link */
  foreach ($links as $link) {
    $result[] = $link->__toString();
  }
  return $result;
}

/**
 * Returns a list of the top n nodes as counted by statistics.module.
 *
 * - Unpublished nodes are not listed.
 * - Stickyness is ignored for ordering, but returned in the results for
 *   client-side ordering if needed.
 *
 * @param int|null $count
 *   Number or entries to return.
 * @param bool|null $daily_top
 *   Order by daily views if TRUE, otherwise by total views (default).
 *
 * @return array|null
 *   Statistics will empty without statistics module.
 *   Note that the title of the nodes is NOT filtered.
 */
function _g2_top($count = NULL, $daily_top = FALSE) {
  $config = Drupal::config('g2.settings');
  $service_max = $config->get('services.top.max_count');
  $api_throttle = $config->get('api.server.throttle');
  $actual_max = $api_throttle * $service_max;

  // Limit extraction.
  if (empty($count) || ($count > $actual_max)) {
    $count = $actual_max;
  }

  /** @var \Drupal\g2\Top $top */
  $top = Drupal::service('g2.top');
  $statistic = $daily_top ? Top::STATISTICS_DAY : Top::STATISTICS_TOTAL;
  $links = $top->getLinks($count, $statistic);
  $result = [];

  /** @var \Drupal\Core\GeneratedLink $link */
  foreach ($links as $link) {
    $result[] = $link->__toString();
  }
  return $result;
}

/**
 * Implements hook_help().
 */
function g2_help($route_name, RouteMatchInterface $route_match) {
  $result = '';
  switch ($route_name) {
    case 'help.page.g2':
      $result = t(
        '<p>G2 defines a glossary service for Drupal sites.
       To compare it with the Glossary and Lexicon modules:</p>
       <ul>
         <li>G2 content is node-based, not term-based, allowing node access control</li>
         <li>G2 leverages existing code from glossary for input filtering and node marking</li>
         <li>G2 RAM use does not significantly increase with larger entry counts, which makes is more suitable for larger glossaries</li>
         <li>G2 requests much less from the database than the default glossary</li>
         <li>G2 uses a "G2 Context" taxonomy vocabulary by default, but does not require it.</li>
         <li>G2 defines optional blocks</li>
         <li>G2 provides a client and server XML-RPC API</li>
         <li>G2 does not provide term feeds</li>
         </ul>'
      );
      break;

    case 'entity.block.edit_form':
      // G2 block plugins contain a "help" annotation.
      $definition = $route_match
        ->getParameter('block')
        ->getPlugin()
        ->getPluginDefinition();
      if ($definition['provider'] !== 'g2') {
        return NULL;
      }
      $result = $definition['help'] ?? '';
      break;

    case 'entity.entity_view_display.node.view_mode':
      if ($route_match->getParameter('entity_type_id') != G2::TYPE) {
        break;
      }
      if ($route_match->getParameter('bundle') !== G2::BUNDLE) {
        break;
      }
      $name = $route_match->getParameter('view_mode_name');
      $args = ['%vm' => EntityViewMode::load(G2::TYPE . ".${name}")->label()];
      switch ($name) {
        case G2::VM_BLOCK:
          $result = t('The %vm display is used by the G2 Random and WOTD blocks.', $args);
          break;

        case G2::VM_ENTRY_LIST:
          $result = t('The %vm display is used by the G2 "terms by initial" page.', $args);
          break;

        case G2::VM_HOMONYMS_PAGE:
          $result = t('The %vm display is used by the G2 homonyms disambiguation page when it is configured to use a node instead of a route', $args);
          break;
      }
      if (!empty($result)) {
        $result = ['#markup' => "<p>${result}</p>\n"];
      }
  }

  return $result;
}

/**
 * Implements hook_theme().
 */
function g2_theme() {
  $config = Drupal::config(G2::CONFIG_NAME);
  $ret = [
    // Checked for D8/9/10.
    'g2_alphabar' => [
      'variables' => [
        'alphabar' => [],
        'row_length' => $config->get(G2::VARALPHABARROWLENGTH),
      ],
    ],
    'g2_entries' => [
      'variables' => [
        'raw_entry' => '',
        'entries' => [],
        'message' => NULL,
        'offer' => NULL,
      ],
    ],
    'g2_initial' => [
      'variables' => [
        'initial' => NULL,
        'entries' => [],
      ],
    ],
    'g2_main' => [
      'variables' => [
        'alphabar' => $config->get(G2::VARALPHABARCONTENTS),
        'text' => '',
      ],
    ],

    // --- Older versions ------------------------------------------------------
    'g2_random' => ['variables' => [G2::TYPE => NULL]],
    'g2_wotd' => ['variables' => [G2::TYPE => NULL]],
  ];
  return $ret;
}

/* ==== Code below this line has not yet been converted to D8 =============== */

/**
 * Remove tags from a taxonomy array for non-G2-admins.
 *
 * @param array $taxonomy
 *   An array of fully loaded terms (tid, vid, weight..)
 *
 * @return array
 *   The taxonomy terms, with tags removed if applicable.
 */
function _g2_comb_taxonomy(array $taxonomy = []) {
  // Filter tag vocabularies for non-G2 admins if this is requested.
  if (variable_get(G2::VARNOFREETAGGING,
      G2::DEFNOFREETAGGING) && !user_access(G2::PERM_ADMIN)) {
    // No static cache here: there is already one in taxonomy_vocabulary_load().
    $vocabs = [];

    // We still hide the terms within freetagging vocabularies to allow partial
    // display.
    foreach ($taxonomy as $tid => $term) {
      // Is the vocabulary for the current term known ?
      $vid = $term->vid;
      if (!array_key_exists($vid, $vocabs)) {
        $vocab = taxonomy_vocabulary_load($vid);
        $vocabs[$vid] = $vocab->tags;
      }

      // If it's a tags vocab, hide its terms.
      if (!empty($vocabs[$vid])) {
        unset($taxonomy[$tid]);
      }
    }
  }

  return $taxonomy;
}

/**
 * Return a formatted set of terms as links.
 *
 * Return a span containing links to taxonomy terms, or nothing
 * if node information contains no terms. The "node" passed must
 * contain full term information, not just tids.
 *
 * @param object $node
 *   Imitation of a node.
 *
 * @return string
 *   The resulting string.
 */
function _g2_entry_terms($node) {
  $ret = NULL;
  if (!empty($node->taxonomy)) {
    $terms = [];
    foreach ($node->taxonomy as $tid => $term) {
      $terms[$tid] = [
        'href' => 'taxonomy/term/' . $term->tid,
        'title' => check_plain($term->name),
        'attributes' => ['rel' => 'tag'],
      ];
    }
    $ret = theme('links', $terms);
  }
  return $ret;
}

/**
 * Translate glossary linking elements (<dfn>) to actual links)
 *
 * This function generates absolute links, for the benefit of the WOTD RSS feed
 * If this feed is not used, it is possible to use the (shorter) relative URLs
 * by swapping comments.
 *
 * @param string $entry
 *   An entry.
 *
 * @return string
 *   HTML.
 */
function _g2_filter_process($entry) {
  // [0] is the original string.
  $entry = $entry[1];
  $target = variable_get(G2::VARREMOTEG2, G2::DEFREMOTEG2);

  // If we are not using a remote glossary.
  if ($target == G2::DEFREMOTENO) {
    $target = G2::PATH_ENTRIES;

    // No tooltips on remote glossaries: too slow.
    if (variable_get(G2::VARTOOLTIPS, G2::DEFTOOLTIPS)) {
      $nodes = g2_entry_load($entry);
      $count = count($nodes);
      if ($count == 1) {
        $node = reset($nodes);
        $tooltip = check_markup($node->teaser, $nodes->format);
      }
      elseif ($count) {
        $tooltip = t(
          '@count entries for @entry',
          [
            '@count' => $count,
            '@entry' => $entry,
          ]
        );
      }
      else {
        $tooltip = t('No such term.');
      }
    }
  }
  else {
    $tooltip = NULL;
  }

  $path = urlencode(G2::encodeTerminal($entry));
  $attributes = [
    'class' => 'g2-dfn-link',
  ];
  if (isset($tooltip)) {
    $attributes['title'] = $tooltip;
  }

  $ret = l(
    $entry,
    $target . '/' . $path,
    [
      'absolute' => TRUE,
      'html' => FALSE,
      'attributes' => $attributes,
    ]
  );
  return $ret;
}

/**
 * Modify the default page title as built by Drupal.
 *
 * Tweaking $conf modifies only the live copy used by Drupal, not the stored
 * value as would be the case using variable_set.
 *
 * @see \Drupal\g2\Controller\Main::indexAction()
 */
function _g2_override_site_name() {
  if (variable_get(G2::VARPAGETITLE, G2::DEFPAGETITLE)) {
    global $conf;
    $conf['site_name'] = strtr(
      variable_get(G2::VARPAGETITLE, G2::DEFPAGETITLE),
      ['@title' => variable_get('site_name', 'Drupal')]
    );
  }
}

/**
 * Submit handler for _g2_referer_links().
 *
 * Use the wipe target to redirect to the wipe confirmation form. If we
 * hadn't been using a button for this link, we could just as well have
 * used a plain link.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function _g2_referer_links_submit(array &$form, FormStateInterface $form_state) {
  $form_state['redirect'] = 'g2/wipe/' . $form_state['values']['wipe_target'];
}

/**
 * Erase the referer counts on g2 entries.
 *
 * Difference from the 4.7 version: it no longer includes a goto when erasing
 * all.
 *
 * @param int $nid
 *   Node from which to erase referers, or NULL to erase all g2 referers.
 *
 * @FIXME 20090928 recheck
 */
function _g2_referer_wipe($nid = NULL) {
  if (isset($nid)) {
    $sq = 'DELETE from {g2_referer} WHERE nid = %d';
    Drupal::database()->query($sq, $nid);
    drupal_goto('node/' . $nid);
  }
  else {
    $sq = 'DELETE from {g2_referer}';
    Drupal::database()->query($sq);
  }
}

/**
 * Returns a structure for the WOTD.
 *
 * @param int $bodysize
 *   The maximum length for the body. Entails truncation.
 *
 * @return object
 *   Title / nid / teaser
 *   Teaser and Body are returned already filtered, not stripped.
 */
function _g2_wotd($bodysize = 0) {
  /** @var \Drupal\g2\WOTD $wotd */
  $wotd = \Drupal::service(G2::SVC_WOTD);
  $node = $wotd->get();
  if (empty($node)) {
    return NULL;
  }

  $node->teaser = check_markup($node->teaser, $node->format);

  $node->truncated = FALSE;
  if ($bodysize > 0) {
    // Save the raw version.
    $node->raw_body = $node->body;
    if (drupal_strlen($node->body) > $bodysize) {
      $node->truncated = TRUE;
      $body = drupal_substr($node->body, 0, $bodysize);
      $node->body = check_markup($body, $node->format);
    }
  }

  return $node;
}

/**
 * Implements hook_access().
 */
function g2_access($op /* , $node, $account */) {
  switch ($op) {
    case 'create':
    case 'delete':
    case 'update':
      $ret = user_access(G2::PERM_ADMIN);
      break;

    case 'view':
      $ret = user_access('access content');
      break;
  }

  return $ret;
}

/**
 * Implements hook_block().
 */
function g2_block($op = 'list', $delta = 0, $edit = []) {
  if ($op == 'configure') {
    switch ($delta) {
      case G2::DELTA_WOTD:
        $form['wotd_feed'] = [
          '#type' => 'fieldset',
          '#title' => t('RSS Feed'),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDLINK] = [
          '#type' => 'checkbox',
          '#title' => t('Display feed link'),
          '#default_value' => variable_get(G2::VARWOTDFEEDLINK,
            G2::DEFWOTDFEEDLINK),
          '#description' => t('Should the theme display the link to the RSS feed for this block ?'),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDTITLE] = [
          '#type' => 'textfield',
          '#title' => t('The feed title'),
          '#size' => 60,
          '#maxlength' => 60,
          '#required' => TRUE,
          '#default_value' => variable_get(G2::VARWOTDFEEDTITLE,
            variable_get(G2::VARWOTDTITLE, G2::DEFWOTDTITLE)),
          '#description' => t(
            'The title for the feed itself.
           This will typically be used by aggregators to remind users of the feed and link to it.
           If nulled, G2 will reset it to the title of the block.'
          ),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDAUTHOR] = [
          '#type' => 'textfield',
          '#title' => t('The feed item author'),
          '#size' => 60,
          '#maxlength' => 60,
          '#required' => TRUE,
          '#default_value' => variable_get(G2::VARWOTDFEEDAUTHOR,
            G2::DEFWOTDFEEDAUTHOR),
          '#description' => t(
            'The author name to be included in the feed entries.
        In this string @author will be replaced by the actual author information.'
          ),
        ];
        $form['wotd_feed'][G2::VARWOTDFEEDDESCR] = [
          '#type' => 'textfield',
          '#title' => t('The feed description'),
          '#size' => 60,
          '#maxlength' => 60,
          '#required' => TRUE,
          '#default_value' => variable_get(G2::VARWOTDFEEDDESCR,
            G2::DEFWOTDFEEDDESCR),
          '#description' => t(
            'The description for the feed itself.
        This will typically be used by aggregators when describing the feed prior to subscription.
        It may contain !site, which will dynamically be replaced by the site base URL.'
          ),
        ];
        break;

      default:
        break;
    }
    $ret = $form;
  }
  elseif ($op == 'save') {
    $ret = NULL;
    switch ($delta) {
      case G2::DELTA_WOTD:
        variable_set(G2::VARWOTDFEEDLINK, $edit[G2::VARWOTDFEEDLINK]);
        variable_set(G2::VARWOTDFEEDTITLE, $edit[G2::VARWOTDFEEDTITLE]);
        variable_set(G2::VARWOTDFEEDDESCR, $edit[G2::VARWOTDFEEDDESCR]);
        variable_set(G2::VARWOTDFEEDAUTHOR, $edit[G2::VARWOTDFEEDAUTHOR]);
        break;

      default:
        break;
    }
  }

  return $ret;
}

/**
 * Implements hook_cron().
 *
 * In G2's case, change the WOTD once a day if this feature is enabled,
 * which is the default case.
 */
function g2_cron() {
  /** @var \Drupal\g2\WOTD $wotdCron */
  $wotd = \Drupal::service(G2::SVC_WOTD);
  $wotd->cron();
}

/**
 * Implements hook_delete().
 */
function g2_delete(&$node) {
  Drupal::database()
    ->query('DELETE FROM {g2_node} WHERE nid = %d', $node->nid);
}

/**
 * Loader for G2_entries.
 *
 * Only returns unpublished nodes to users with "administer nodes".
 *
 * @param string $title
 *   The title to look for.
 *
 * @return array
 *   Nodes matching the title.
 *
 * @see _g2_filter_process
 */
function g2_entry_load($title) {
  $sq = <<<SQL
SELECT n.nid
FROM {node} n
WHERE n.type = '%s' AND n.status >= %d AND n.title LIKE '%s%%';
SQL;
  $sq = db_rewrite_sql($sq);

  $min_status = user_access('administer nodes')
    ? Node::NOT_PUBLISHED
    : Node::PUBLISHED;
  $q = Drupal::database()->query($sq, G2::BUNDLE, $min_status, $title);
  $nodes = [];
  while (is_object($node = db_fetch_object($q))) {
    $nodes[$node->nid] = Drupal::service('entity_type.manager')
      ->getStorage(G2::TYPE)
      ->load($node->nid);
  }
  return $nodes;
}

/**
 * Implements hook_filter().
 *
 * @link http://drupal.org/node/267484 @endlink
 * @link http://drupal.org/node/209715 @endlink
 */
function g2_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return [0 => t('G2 Glossary filter')];

    case 'description':
      return t('Allows users to link to G2 entries using &lt;dfn&gt; elements.');

    case 'prepare':
      $text = preg_replace('@<dfn>(.+?)</dfn>@s', "[g2-dfn]\\1[/g2-dfn]",
        $text);
      return $text;

    case "process":
      $text = preg_replace_callback('@\[g2-dfn\](.+?)\[/g2-dfn\]@s',
        '_g2_filter_process', $text);
      return $text;

    default:
      return $text;
  }
}

/**
 * Implements hook_filter_tips().
 */
function g2_filter_tips($delta, $format, $long = FALSE) {
  $ret = $long
    ? t('Wrap &lt;dfn&gt; elements around the terms for which you want a link to the available G2 definition(s).')
    : t('You may link to G2 definitions using &lt;dfn&gt; elements.');
  return $ret;
}

/**
 * Menu loader for g2_node.
 *
 * @param int $us_nid
 *   The id of the node to load.
 *
 * @return object|false|null
 *   The load result.
 */
function g2_node_load($us_nid = 0) {
  // Safety with regard to $us_nid is checked within node_load()
  if (is_numeric($us_nid)) {
    $node = Drupal::entityTypeManager()
      ->getStorage(G2::TYPE)
      ->load($us_nid);
  }
  else {
    $node = reset($us_nid);
  }
  if ($node->getEntityTypeId() != G2::BUNDLE) {
    $node = NULL;
  }

  return $node;
}

/**
 * Implements hook_perm().
 *
 * The extended form used here is drawn from the D7 version.
 */
function g2_perm() {
  $ret = array_keys(
    [
      G2::PERM_ADMIN => [
        'title' => t('Administer G2 entries'),
        'description' => t(
          'Access administrative information on G2 entries. This permission does not grant access to the module settings, which are controlled by the "administer site configuration" permission.'
        ),
      ],
    ]
  );

  return $ret;
}

/**
 * Submit handler for "wipe referers" button.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function g2_referer_wipe_button_submit(
  array $form,
  FormStateInterface $form_state
) {
  drupal_goto('g2/wipe');
}

/**
 * Form builder for the referer wipe confirmation request form.
 *
 * This is the same form for both global wipe and individual node wipe.
 *
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 * @param null|\Drupal\node\NodeInterface $node
 *   The node from which to erase.
 *
 * @return array
 *   A render array for the confirm form.
 */
function g2_referer_wipe_confirm_form(
  FormStateInterface $form_state,
  NodeInterface $node = NULL
) {
  $form = [];

  if (is_object($node) && isset($node->nid)) {
    $question = t('Are you sure to want to erase the referer information on this G2 entry ?');
    $cancel = 'node/' . $node->nid . '/referers';
    $form[G2::TYPE] = [
      '#prefix' => '<p><em>',
      '#value' => check_plain($node->title),
      '#suffix' => '</em></p>',
    ];
  }
  else {
    $question = t('Are you sure to want to erase the referer information on all G2 entries ?');
    $cancel = G2::PATH_SETTINGS;
  }

  $ret = confirm_form(
    $form,
    $question,
    $cancel,
    t('This action cannot be undone.'),
    t('Confirm'),
    t('Cancel')
  );
  return $ret;
}

/**
 * Submit handler for referer wipe confirmation.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function g2_referer_wipe_confirm_form_submit(array $form, FormStateInterface $form_state) {
  _g2_referer_wipe();
  Drupal::messenger()
    ->addStatus(t('Referer information has been erased on all G2 entries'));
  $form_state['redirect'] = G2::PATH_SETTINGS;
}

/**
 * Implements hook_user().
 *
 * @todo D6 check when content is actually there
 */
function g2_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'load':
      // Issue #1047248: unused n.changed and n.created columns are for PGSQL.
      $sq = <<<SQL
SELECT n.nid, n.title, n.changed, n.created
FROM {node} n
WHERE n.type = '%s' AND n.status  = 1 AND n.uid = %d
ORDER BY n.changed DESC, n.created DESC;
SQL;
      $sq = db_rewrite_sql($sq);
      $q = db_query_range($sq, G2::BUNDLE, $account->uid, 0, 10);
      $account->nodes = [];
      while (is_object($o = db_fetch_object($q))) {
        $account->nodes[] = [
          'value' => l($o->title, 'node/' . $o->nid, ['absolute' => TRUE]),
        ];
      }
      break;

    case 'view':
      $nodes = [];
      if (is_array($account->nodes)) {
        foreach ($account->nodes as $node) {
          $nodes[] = $node['value'];
        }
      }
      $account->content['summary']['g2'] = [
        '#type' => 'user_profile_item',
        '#title' => t('Owned G2 definitions'),
        '#value' => theme('item_list', $nodes),
        '#description' => t('10 most recently changed only'),
      ];
      break;

    default:
      break;
  }
}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function g2_node_view(array &$build, EntityInterface $node, EntityViewDisplayInterface $display, $view_mode) {
  if ($node->bundle() != G2::BUNDLE) {
    return;
  }
  $config = Drupal::config(G2::CONFIG_NAME);

  // On the WOTD feed, force the node date to the WOTD date or current time.
  if ($view_mode === 'rss' &&
    Drupal::routeMatch()->getRouteName() === G2::ROUTE_FEED_WOTD) {
    $node->created = (Drupal::state()->get(G2::VARWOTDDATE) ?: time());
  }

  if ($config->get('controller.main.log_referrers')) {
    _g2_insert_referrer($node);
  }

  return $node;
}

/**
 * Implements hook_views_api().
 */
function g2_views_api() {
  return [
    'api' => '2.0',
    'path' => ExtensionPathResolver::getPath('module', 'g2') . '/views',
  ];
}

/**
 * Implements hook_xmlrpc().
 *
 * Note that functions returning node portions return them unfiltered.
 * It is the caller's responsibility to apply filtering depending on
 * its actual use of the data.
 */
function g2_xmlrpc() {
  /** @var \Drupal\g2\Random svcRandom */
  $mapping = [
    'g2.alphabar' => '_g2_alphabar',
    'g2.api' => '_g2_api',
    'g2.latest' => '_g2_latest',
    'g2.random' => [\Drupal::service(G2::SVC_RANDOM), 'get'],
    'g2.stats' => '_g2_stats',
    'g2.top' => '_g2_top',
    'g2.wotd' => '_g2_wotd',
  ];

  $enabled = Drupal::config(G2::CONFIG_NAME)->get('api.server.enabled');
  if (!$enabled) {
    $mapping = [];
  }

  return $mapping;
}

/**
 * Theme a random entry.
 *
 * This is actually a short view for just about any single node, but it
 * is even shorter than node_view($node, TRUE).
 *
 * @param object $node
 *   A node to display.
 *
 * @return string
 *   HTML: the themed entry.
 */
function theme_g2_random($node = NULL) {
  $ret = l($node->title, 'node/' . $node->nid);
  if ($node->teaser) {
    // Why t() ? Because varying languages have varying takes on spaces
    // before/after semicolons.
    $ret .= t(': @teaser', ['@teaser' => $node->teaser]);
  }
  // No need to test: also works on missing taxonomy.
  $ret .= _g2_entry_terms($node);
  $ret .= theme('more_link', url('node/' . $node->nid), t('&nbsp;(+)'));
  return $ret;
}

/**
 * Theme a WOTD block.
 *
 * @param \Drupal\node\Entity\Node|null $node
 *   The node for the word of the day. teaser and body are already filtered and
 *   truncated if needed.
 *
 * @return string
 *   Title / nid / teaser / [body].
 */
function theme_g2_wotd(Node $node = NULL) {
  if (empty($node)) {
    return NULL;
  }

  // l() check_plain's text.
  $link = l($node->title, 'node/' . $node->nid);
  if (isset($node->teaser) and !empty($node->teaser)) {
    // Teaser already filtered by _g2_wotd(), don't filter twice.
    $teaser = '<span id="g2_wotd_teaser">' . strip_tags($node->teaser) . '</span>';
    $ret = t(
      '!link: !teaser',
      [
        '!link' => $link,
        '!teaser' => $teaser,
      ]
    );
    unset($teaser);
  }
  else {
    $ret = $link;
  }

  if (!empty($node->body)) {
    // Already filtered by _g2_wotd(), don't filter twice, just strip.
    $body = strip_tags($node->body);
    if ($node->truncated) {
      $body .= '&hellip;';
    }
    $ret .= '<div id="g2_wotd_body">' . $body . '</div>';
  }
  $node->taxonomy = _g2_comb_taxonomy($node->taxonomy);
  // No need to test: it won't change anything if no taxonomy was returned.
  $ret .= _g2_entry_terms($node);
  $ret .= theme('more_link', url('node/' . $node->nid), t('&nbsp;(+)'));
  if (variable_get(G2::VARWOTDFEEDLINK, G2::DEFWOTDFEEDLINK)) {
    $ret .= theme(
      'feed_icon',
      url(G2::ROUTE_FEED_WOTD, ['absolute' => TRUE]),
      t('A word a day in your RSS reader')
    );
  }

  return $ret;
}
